# lem_in cookbook
This is lem-in project which we fulfil in 21-school.
For the moment, this article is in Russian only. For those who seek English version please refer to Google translator.
Or write to _msahbet@yandex.ru_ to push me for give an adequate translation

## Общая задача: 
имеются комнаты, которые связаны между собой трубами. Комнаты и связи между ними описаны на карте. Есть генератор карт, а также некоторые примеры карт находятся в папке ```maps```. В карте сначала приводится перечисление названий комнат с координатами, а далее приводятся связи между комнатами. В комнате, перед которой команда ```##start```, находятся ```N``` муравьев. ```N``` написано в первой строчке файла карты. Последняя комната имеет перед собой команду ```##end```. Любые другие строчки-комментарии начинаются с ```#```. Пример карты: 

```
##start
abc 100 140
abcd 110 150
rr 180 200
gfh 200 240
##end
Tr_s 230 300
abc-abcd
abcd-rr
rr-gfh
gfh-Tr_s
```
Задача состоит в том, чтобы найти непересекающиеся пути. Далее по этим путям пустить муравьев. В промежуточных комнатах не может находиться более одного муравья. В начальной и конечной комнатах может быть любое кол-во муравьев. Шагом считается переход муравьев из одной комнаты в другую. При параллельных путях, за один шаг муравьи идут независимо друг от друга. Задача состоит в том, чтобы кол-во шагов было минимально. Решение оформляется в цепочку, состоящую из команта, которые посещает каждый из муравьев.


Проект является парным. С самого начала лучше разделиться и каждому из напарников выполнять свою часть. Для любителей разбираться, можете пробовать разираться во всех деталях. Тогда также бульте готовы пожертвовать 1-3 месяца упороной ежедневной работы. Задачи между собой можно разбить различными способами. Каждый тамдем сам волен выбирать распределение задач и нагрузку на каждого. Необязательно распределять задачи поровну. Как говорится, каждому столько, сколько он может выдержать.
## Разбиение задач
	Напарник 1: Алгоритм
	Напарник 2: Чтение карты, ввод данных в структуру, вывод сообщений об ошибках, чистка структуры при ошибках лиюо успешном завершении работы программы.
 
 Алгоритм может быть совершенно различным. Он ограничен только вашей фантазией. Кто-то делает по Суурбале (привет вашему мозгу), кто-то решает общую задачу максимализации потока через сеть (алгоритм Эдмондса — Карпа) (чуть меньший привет вашему мозгу), кто-то ищет минимальный путь через алгоритм Дейкстры (оставьте привет себе). Здесь же предлагется чуть видоизмененный алгоритм Йена. Алгоритм Йена позволяет находить k-ый по длине путь от одной одной вершины до другой в графе. Но эти пути могут пересекаться. Интересующимся гугл в помощь.

### Prerequisites
Для успешной реализации проекта вам должны быть хорошо знакомы следующие алгоритмы. Рекаомендуется сначала потренироваться на них, решая эти задачи, а далее приступать к восхождению на вершину муравейника. Не все эти задачи непосредственно нужны для проекта, но они представляют более полный набор алгоритмов при работе с графами.
0. Предлагаю сразу завести структуру t_bool, которая может принимать два значения: false и true.
typedef enum
{
	false,
	true
}	t_bool;

1. Реализация функций для работы с очередью:
	* создание очереди (queue_init), 
	* удаление очереди (queue_delete), 
	* добавление элемента в очередь (queue_insert), 
	* удаление первого элемента в очереди и возвращение его (queue_pop), 
	* проверка заполненности очереди (queue_is_full). Если очередь полна, нет смысла класть в нее новый элемент (queue_insert).
	* проверка того, что очередь пуста. Если очередь пуста, мы не можем вытащить из нее элемент. Например, при работе с положительными числами возвращаем -1.
	* распечатка очереди (queue_print)
	* показывает первый элемент очереди либо -1, если очередь пуста (queue_top). Эта функция в отличии от queue_pop не удаляет первый элемент.

Структура для очереди может выглядить так:
	typedef struct		s_queue
	{
		int 			*front;
		int 			*rear;
		int 			n;
	}					t_queue;
Здесь front - указатель на начало стека, rear - указатель на следующий после последнего элемент очереди, n - максимальная длина очереди, а именно, под столько элементов была выделена память.

Экземпляр очереди:
t_queue *Q; 
Функции для работы с очередью:
void	queue_init(t_queue *Q, int size);
void	queue_delete(t_queue *Q);
int		queue_insert(t_queue *Q, int x);
int		queue_pop(t_queue *Q);
int		queue_is_empty(t_queue *Q);
int		queue_is_full(t_queue *Q);
void	queue_print(t_queue *Q);
int		queue_shine_first(t_queue *Q);

2. Реализация функций для работы со стеком. Сам стек можно делать как удобно: через связаные листы (linked list) или массив. Я выбираю массив по следующим причинам: выделение памяти происходит один раз и элементы в памяти располагаются друг за другом. Структура стека:

typedef struct		s_stack
{
	int				*arr;
	int				ptr;
	int				len;
}					t_stack;

Функции стека:
	* создание стека (initiate_stack), что выделяет память.
	* удаление стека (delete_stack),
	* узнаем, пуст ли стек (is_empty_stack),
	* узнаем, полон ли стек (is_full_stack),
	* если стек не полный, добавлям элемент в него (append_to_stack),
	* удаляем "верхний" элемент из стека и возвращаем его. При работе с положительными числами при невозможности извлечения элемента возвращаем -1 (pop_from_stack),
	* "высвечиваем" "верхний" элемент стека (top_in_stack),
	* распечатываем стека (print_stack)

Экземпляр стека:
t_stack *S;

t_stack		*initiate_stack(int n);
void		delete_stack(t_stack *stack);
t_bool		is_empty_stack(t_stack *stack);
t_bool		is_full_stack(t_stack *stack);
t_bool		append_to_stack(t_stack *stack, int value);
int			pop_from_stack(t_stack *stack);
int			top_in_stack(t_stack *stack);
void		print_stack(t_stack *stack);

_Примечание:_ Вы могли заметить, что я предлагаю два разных способа функций при работе с очередью и со стеком: 
void	queue_init(t_queue *Q, int size) - принимает ссылку и по ней выделяет память. 
t_stack		*initiate_stack(int n) - в самой функции создается ссылка, по ней выделяется память и эта ссылка возвращается. Вы можете придерживаться любого способа.
Вы также можете поступить следующим образом:
void	queue_init(t_queue **Q, int size) - здесь принимается адрес указателя, выделяется память и адрес выделенной памяти записыватся в адрес указателя Q.

3. BFS (breadth-first search) - обход графа в ширину. На вход подается граф и  вершина, с которой программа начинает обход. На выходе массив, соответсвующий порядку обхода каждой вершины. BFS реализуется с помощью очереди.

4. DFS (depth-first search) - обход графа в глубину. На вход подается граф и вершина, с которой начинаем обход. DFS реализуется с помощью стека. 

	(для дальнейшего описания назовем её t_map, а её экземпляр ), 


 Но исходя из выбранной структуры (глобальные переменные использовать нельзя) предлагается следующее:

### map parsing
1. Сделать так, чтобы name1-name1 ловилось и выдавалась ошибка
2. То же саоме если встречается name1-name2, и далее, через некоторое время name2-name1. 
3. Убедиться в том, что никакая комната не начинается с L.
4. ~~Если комнаты закончились, и пошла строка с '-', то flag_rooms = 1. Если дальше идет комната, то есть мы не встречаем '-', выводим ошибку.~~

### algorithm
##### ограничить максимальное количество путей.
1. Посмотреть, сколько соседей у start_vertex и end_vertex. Минимальное количество из этих двух чисел и есть максимальное количество путей. 
Если в середине графа все ок, значит столько путей и есть. Если где-то в середие "сужение путей" либо узловая точка либо 
мост, значит путей горазо меньше.
2. Update max_paths.

##### bfs
1. реализовать bfs с помощью очереди (queue). 
7. Сразу после bfs убедиться, что start_vetex и end_vertex находятся в одной компоненте смежности. То есть, что вообще, существует путь.
2. Во время bfs присвоить каждой вершине (vertex) свой номер уровня bfs (bfs_level)
3. расстовить "стрелочки", от меньшего bfs_level до большего.
4. для каждой вершины посчитать количество входящих и исходящих "стрелочек". (in, out).
5. выборосить dead-ends. Если in > 0, а out == 0, значит это тупиковая вершина. Ее со всеми связями нужно удалить. Кроме start_vertex, end_vertex.
6. То же самое для out > 0, in == 0, хотя таких вершин скорее всего нет. _Подумать_ над этим. 
7. Получить кратчайший путь между start_vetex и end_vertex.

##### dfs
1. Сосавить список узловых точек. То же самое для мостов.
2. Скорее всего их нужно искать с помощью dfs. (Если можно найти с помощью bfs, еще лучше. Подумать над этим).
3. Допустим, есть узловые точки / мосты. Узнать,связывают ли они start_vetex и end_vertex. Потому что, если их наличие не
оставляет start_vetex и end_vertex в разных компонентах связности, то нам все равно на их существование.
4. Допустим, в итоге мы находим такую вершину либо мост, при удалении которых start_vetex и end_vertex перестают быть связными.
Это значит, что даже если со start_vertex стартуют несколько непересекающихся путей, они сойдутся в этом мосту/узле. Тогда нет 
смысла искать несколько путей. Ограничиваемся тем коротким путем, что уже есть. И по нему будем двигать муравьев.


##### перед алгоритмом Йена.
1. После bfs у нас уже есть короткий путь. Надо посмотреть каждую вершину на наличие вилок. Вилка - это если входит 1, а выходит 2.
Или наоборот. В общем, есть входящие вилки, например, in = 2, out = 1. Есть исходящие вилки: in = 1, out = 2. Это пример. out может 
быть и > 2.
2. Теперь допустим, что у короткого пути нет вилок, а значит, in = 1, out = 1. Это значит, что короткий путь есть тоннель, который
дальше разбирать нет смысла. Мы его сохраняем. Сохраняем весь путь от start_vetex до end_vertex. В массив? 
3. (Open question) Также хороший вопрос в том, что можем ли мы до конца раздраконить весь граф или нам его надо хранить полностью до конца алгоритма?
4. После сохранения пути мы удаляем вершины этого пути и его связи (links). 
5. Продолжаем до тех пор, пока start_vetex либо end_vertex не станут изолированными. Или мы не достигнем max_paths. _Или это одно и тоже?_

##### алгоритм Йена.
-1. Суурбале: http://www.macfreek.nl/memory/Disjoint_Path_Finding
0. https://www.e-olymp.com/ru/problems/4394
1. Алгоритм заключается в том, чтобы найти кратчайший путь. Далее по очереди мы убираем каждый из ребер (куда убираем?) и находим 
кратчайший путь p1. Убираем вершины, которые в p1, находим следующий кратчайший путь p2. и так далее пока недобьёмся max_paths. 
Составили список. Далее вернули то ребро, которые убрали, на место. Перешли к следующему ребру. и т.д. В итоге для каждого "удаленного"
ребра получаем списко путей. Нужно выбрать то ребро, при удалении которого находим список путей, которые являются кратчайшими.
Возможно сумбурно, но надо попробовать.
В Папке literature лежат статьи, которые нужно разобрать.



##### финал.
1. итеративно выводим пути.
2. Чистим все.
3. Вообще организуем чистку (free) при наличии ошибок.
