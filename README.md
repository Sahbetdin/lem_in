# lem_in cookbook
This is lem-in project which we fulfil in 21-school.
For the moment, this article is in Russian. For those who seek English version please refer to Google translator.
Or write to msahbet@yandex.ru to push me for give an adequate translation



## Разбиение задач
Проект является парным. С самого начала лучше разделиться и каждому из напарников выполнять свою часть. Можно по-разному разбить задачи. Каждый тамдем сам волен выбирать распределение задач. Но исходя из выбранной структуры (глобальные переменные использовать нельзя) предлагается следующее:
  Напарник 1: Алгоритм
  Напарник 2: Чтение карты, ввод данных в структуру, вывод сообщений об ошибках, чистка структуры при ошибках/успехе.
 
 Алгоритм может быть совсем различным. Он ограничен только вашей фантазией. Кто-то делает по Суурбале, кто-то решает общую задачу максимализации потока через сеть (алгоритм Эдмондса — Карпа). Здесь предалагется чуть видоизмененный алгоритм Йена. В целом, алгоритм Йена позволяет находить k-ый путь одной одной вершины до другой в графе. 

### Prerequisites
Для успешной реализации проекта вам нужно быть хорошо знакомымы следующие алгоритмы. То есть, потренируйтесь сначала, решая эти задачи, а далее приступайте в восходу на вершину муравейника. Не все эти задачи нужны непосредственно для проекта, но они представляют более полный набор алгоритмов при работе с графами.
Реализация функций для работы с очередью: создание очереди (queue_init), удаление очереди, добавление  
1. BFS (breadth-first search) - обход графа в ширину
2. DFS (depth-first search) - обход графа в глубину

  (для дальнейшего описания назовем её t_map, а её экземпляр ), 


### map parsing
1. Сделать так, чтобы name1-name1 ловилось и выдавалась ошибка
2. То же саоме если встречается name1-name2, и далее, через некоторое время name2-name1. 
3. Убедиться в том, что никакая комната не начинается с L.
4. ~~Если комнаты закончились, и пошла строка с '-', то flag_rooms = 1. Если дальше идет комната, то есть мы не встречаем '-', выводим ошибку.~~

### algorithm
##### ограничить максимальное количество путей.
1. Посмотреть, сколько соседей у start_vertex и end_vertex. Минимальное количество из этих двух чисел и есть максимальное количество путей. 
Если в середине графа все ок, значит столько путей и есть. Если где-то в середие "сужение путей" либо узловая точка либо 
мост, значит путей горазо меньше.
2. Update max_paths.

##### bfs
1. реализовать bfs с помощью очереди (queue). 
7. Сразу после bfs убедиться, что start_vetex и end_vertex находятся в одной компоненте смежности. То есть, что вообще, существует путь.
2. Во время bfs присвоить каждой вершине (vertex) свой номер уровня bfs (bfs_level)
3. расстовить "стрелочки", от меньшего bfs_level до большего.
4. для каждой вершины посчитать количество входящих и исходящих "стрелочек". (in, out).
5. выборосить dead-ends. Если in > 0, а out == 0, значит это тупиковая вершина. Ее со всеми связями нужно удалить. Кроме start_vertex, end_vertex.
6. То же самое для out > 0, in == 0, хотя таких вершин скорее всего нет. _Подумать_ над этим. 
7. Получить кратчайший путь между start_vetex и end_vertex.

##### dfs
1. Сосавить список узловых точек. То же самое для мостов.
2. Скорее всего их нужно искать с помощью dfs. (Если можно найти с помощью bfs, еще лучше. Подумать над этим).
3. Допустим, есть узловые точки / мосты. Узнать,связывают ли они start_vetex и end_vertex. Потому что, если их наличие не
оставляет start_vetex и end_vertex в разных компонентах связности, то нам все равно на их существование.
4. Допустим, в итоге мы находим такую вершину либо мост, при удалении которых start_vetex и end_vertex перестают быть связными.
Это значит, что даже если со start_vertex стартуют несколько непересекающихся путей, они сойдутся в этом мосту/узле. Тогда нет 
смысла искать несколько путей. Ограничиваемся тем коротким путем, что уже есть. И по нему будем двигать муравьев.


##### перед алгоритмом Йена.
1. После bfs у нас уже есть короткий путь. Надо посмотреть каждую вершину на наличие вилок. Вилка - это если входит 1, а выходит 2.
Или наоборот. В общем, есть входящие вилки, например, in = 2, out = 1. Есть исходящие вилки: in = 1, out = 2. Это пример. out может 
быть и > 2.
2. Теперь допустим, что у короткого пути нет вилок, а значит, in = 1, out = 1. Это значит, что короткий путь есть тоннель, который
дальше разбирать нет смысла. Мы его сохраняем. Сохраняем весь путь от start_vetex до end_vertex. В массив? 
3. (Open question) Также хороший вопрос в том, что можем ли мы до конца раздраконить весь граф или нам его надо хранить полностью до конца алгоритма?
4. После сохранения пути мы удаляем вершины этого пути и его связи (links). 
5. Продолжаем до тех пор, пока start_vetex либо end_vertex не станут изолированными. Или мы не достигнем max_paths. _Или это одно и тоже?_

##### алгоритм Йена.
-1. Суурбале: http://www.macfreek.nl/memory/Disjoint_Path_Finding
0. https://www.e-olymp.com/ru/problems/4394
1. Алгоритм заключается в том, чтобы найти кратчайший путь. Далее по очереди мы убираем каждый из ребер (куда убираем?) и находим 
кратчайший путь p1. Убираем вершины, которые в p1, находим следующий кратчайший путь p2. и так далее пока недобьёмся max_paths. 
Составили список. Далее вернули то ребро, которые убрали, на место. Перешли к следующему ребру. и т.д. В итоге для каждого "удаленного"
ребра получаем списко путей. Нужно выбрать то ребро, при удалении которого находим список путей, которые являются кратчайшими.
Возможно сумбурно, но надо попробовать.
В Папке literature лежат статьи, которые нужно разобрать.



##### финал.
1. итеративно выводим пути.
2. Чистим все.
3. Вообще организуем чистку (free) при наличии ошибок.
